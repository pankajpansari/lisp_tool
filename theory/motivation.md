In this project, we aim to study one aspect of reasoning capability of LLMs. We do this in the context of the Scheme language - given a set of primitive functions, we give tasks in natural langugage to the LLM that require composition of those primitive functions to derive higher-order, more complex functions. At every point, the LLM has access to the cache of functions it has already composed. Given any task, if none of the functions can solve that task in a single call, the LLM decides to compose the appropriate function and add it to its cache. 

We choose Scheme, a dialect of Lisp, because it provides an elegant framework to compactly express complex computations in terms of a small number of pre-defined primitive functions in a recursive manner. The use of recursion makes the composition of functions more challenging, thereby increasing the difficulty of the reasoning tasks. We specify the necessary rules and syntax to enable the LLM to put together a valid, recursive function.

It is important that the LLM is not able to make use of the knowledge present in the LISP programs it encountered during training to solve these reasoning tasks. To ensure that our reasoning tasks do not degenerate to code completion, we encode the standard primitive names, either reversing them or using some encoding scheme. This also means we have to decode the LLM output before passing to the Scheme interpreter to check for correctness.

The first attempt will be based on curriculum learning where we gradually increase the difficulty of tasks presented to the LLM. If the current tasks needs a new function definition, the LLM will have access to all the building blocks in its cache. A harder task will be to directly present the LLM with a hard task, and see whether it can figure out how to build intermediate functions, add them to the cache, and compose them to solve the given task. Finally, we can attempt to withold one or more primitive function and test whether the LLM is able to discover them on its own.